=====.ASCIS
Directive defining values of single bytes using passed string argument. Last byte has toggled (XOR-ed) most significant bit.

Syntax:
 
[<label>[:]] .ASCIS <expr> | txtexpr { , <expr> | txtexpr }	 

Example:
 
alpha: .ASCIS "ABC" ; generates bytes $41, $42, $C3	   
beta:  .ASCIS "Stop",$D ; generates bytes ‘S’, ‘t’, ‘o’, ‘p’, $8D	 

Description:
.ASCIS directive is helpful to generate string with it's end marked by toggling most significant bit.

=====.BYTE or .DB or .ASCII
Directive defining values of single bytes using passed arguments.

Syntax:
 
[<label>[:]] .DB <expr> | txtexpr { , <expr> | txtexpr }	   
[<label>[:]] .BYTE <expr> | txtexpr { , <expr> | txtexpr }	   
[<label>[:]] .ASCII <expr> | txtexpr { , <expr> | txtexpr }	 

Example:
 
alpha: .DB "ABC", 0 ; generates bytes ‘A’, ‘B’, ‘C’, 0	   
beta:  .DB %1, %1$  ; macro params; string length and string itself	   
 .BYTE <[alpha-1], >[alpha-1]	   
 .ASCII "Text"	 

Description:
.DB (.BYTE, .ASCII) directive generates and defines single byte values. Input data might be entered in numerical or string form. Numerical expressions are also accepted.

=====.WORD or .DW
Directive defining word values. Words are written according to low-endian 6502 convention: low byte first, high byte follows.

Syntax:

[<label>[:]] .DW expr { , expr }
[<label>[:]] .WORD expr { , expr }

Example:

alpha: .DW $1234, 0 ; generates sequence $34, $12, 0, 0	   
beta:  .WORD alpha	   
       .WORD alpha-1, beta	 

=====.DBYTE or .DD
Directive defining double byte values. Double bytes numbers are written according to big-endian convention: high byte first, low byte follows.

Syntax:

[<label>[:]] .DD expr { , expr }
[<label>[:]] .DBYTE expr { , expr }

Example:

alpha: .DD $1234, 0 ; generates sequence $12, $34, 0, 0
beta:  .DBYTE alpha	   
       .DBYTE alpha-1, beta	 

=====.STR or .STRING
Directive defining byte values using passed string argument. First generated byte contains string length. Rest of bytes are verbatim copies of string characters. String length is limited to 255 characters.

Syntax:
 
[<label>[:]] .STR expr { , expr }	   
[<label>[:]] .STRING expr { , expr }	 

Example:

alpha: .STRING "ABC", $D ; generates sequence 4, ‘A’, ‘B’, ‘C’, $0D	   
beta:  .STR "Test string", $D, $A	   
       .STR "AB", "CD", 13 ; generates: 5, ‘A’, ‘B’, ‘C’, ‘D’, $0D	 
=====.DCB
Directive reserving memory area with initialization of reserved memory by given value.

Syntax:
 
[<label>[:]] .DCB expr [ , expr ]	 

Example:
 
buf: .DCB $20,$FF  ; next $20 bytes is reserved and set to $FF	 
+K# $ .RS lub .DS
Directive reserving memory area by adding given value to the pointer of current location.

Syntax:
 
[<label>[:]] .RS expr	 

Example:
 
buf: .RS $100 ; reserve $100 bytes	   
     .RS size ; same as *= * + size	   

=====.OPT
Directive setting assembly options. The only allowed options are:

 
Option Name	Meaning	   
Proc6502	select basic command set of 6502 microprocessor
Proc65c02	select extended command set of 65c02, 6501 and other microprocessors
Proc6501	ditto
CaseSensitive	treat lowercase and uppercase letters in label names as different
CaseInsensitive	treat lowercase and uppercase letters in label names as same

Syntax:

 .OPT option_name { , option_name }

Example:

 .OPT Proc65c02, CaseInsensitive
=====.ORG lub *=
Directive setting code generation location.

Syntax:

[<label>[:]] .ORG expr	 

Example:
 
 *= $1000  ; code location: $1000	   
buf: .ORG * + $10 ; offset code location by $10 bytes,	   
           ; label ‘buf’ will be set to previous code location address	 
=====.START
Directive setting simulator entry (start) point address.

Syntax:
 
 .START expr	 

Example:
 
 .START Start ; start program execution from ‘Start’ address	   
 .START $A100 ; start program execution from $A100 address	 

Description:
.START directive selects simulator entry point. Simulator will attempt to launch program using given address. If there is no .START directive used, simulator tries to start execution using address specified by first .ORG directive. .START directive allows using forward referencing (unlike .ORG).
=====.END
Directive finishing source code assembly.

Syntax:
 
[<label>[:]] .END	 

Example:
 
fin: .END  ; rest of source code in current file won't be assembled	 

Description:
	.END directive finishes assembly process of the file it was placed in. Used in main source file finishes assembly in the line it is placed.
=====.INCLUDE
Directive including source file to assembly.

Syntax:
 
 .INCLUDE txt_expr	 

Example:
 
 .INCLUDE "c:\asm6502\const_vals.65s"	   
 .INCLUDE ".\macros\macros"	 

Description:
.INCLUDE directive includes given source code file. S¹ one wstawiane w miejscu wywo³ania dyrektywy .INCLUDE. Pozwala to na ³atwe do³¹czanie plików z definicjami sta³ych i makr.
=====.MACRO
Directive opening macro definition.

Syntax:
 
<label>[:] .MACRO [param {, param} [, ...]] | [...]	 

Example:
 
PushX  .MACRO      ; parameterless macro	   
Print: .MACRO ...  ; macro accepting any number of params	   
Put:   .MACRO chr  ; macro accepting exactly one parameter	 

Description:
.MACRO directive defines block of code (macro definitions). Label placed before .MACRO becomes macro definition name and is placed in macro name dictionary (which is separate from label names dictionary).
After .MACRO directive one can place macro parameters and/or ellipsis (...). Parameter name can then be used in macro definition block. Defined parameters will be required when macro is used later in source code. To pass any number of parameters (also none) one can use ellipsis (...). If there are no params defined macro can be invoked without params only.
To use params inside macro definition one can use their names or consecutive numbers (starting from 1) preceded by '%' character. Param number zero (%0) has special meaning--it contains number of actual parameters macro was invoked with. Instead of numbers numeric expression can be used if they are enclosed in square brackets (for example %[.cnt+1]).
In macro invocation actual parameters are placed after macro name. Param expressions are separated by commas. All those expression are assembly time expressions. They get interpreted and calculated and result values are passed to macro definition.
All the labels starting with dot (.) are local to macro definition block and are not accessible nor visible from the outside code using macrodefinition. All the other labels are global. Macrodefinition code can use local labels (from the place it was invoked), global labels, as well as it's own local labels.
Macro definition parameters could be referenced with '$' suffix. If given param was passed as string it is still accessible as string using dollar sign. Accessing it without '$' suffix returns string length. Param 0$ has special meaning: macro name.

Example:
Put:	.MACRO chr		; print single character
	LDA #chr		; load value of parameter ‘chr’
	JSR sys_put_char
	.ENDM
; invocation:
	Put ’A’

Print:	.MACRO ...	; printing
.cnt	.= 0			; param counter
	.REPEAT %0
.cnt	.= .cnt + 1
	.IF .PARAMTYPE(%.cnt) == 2	; text param?
	  JSR sys_print_text	; string is placed *after* procedure call
	  .BYTE .STRLEN(%.cnt), %.cnt
	.ELSE					; numerical param -> address of string
	  LDA #>%.cnt		; high address byte
	  LDX #<%.cnt		; low address byte
	  JSR sys_print
	.ENDIF
	.ENDR
	.ENDM


=====.ENDM
Directive closing macro definition block. Check also .MACRO

Syntax:
 
 .ENDM	 

Example:
 
 .ENDM  ; end of macro definition	 
=====.EXITM
Directive stopping macro inserting.

Syntax:
 
 .EXITM	 

Example:
 
 .EXITM ; all the rest of macro code won't be inserted	   
        ; in place it was invoked	 

=====.IF
Directive opening conditional assembly block.

Syntax:
 
 .IF expr	 

Example:
 
 .IF .REF(alpha) ; if 'alpha' label was referenced	   
 .IF a==5  ; if label 'a' equals 5	   
 .IF b     ; if label 'b' has non-zero value	   
 .IF %0>2  ; if macro invoked with more then two params	   
 	 

=====.ELSE
Directive of conditional assembly.

Syntax:
 
 .ELSE	 

Example:
 
 .ELSE  ; if condition after .IF directive wasn't <> 0	   
   ; then following lines will be assembled	 

=====.ENDIF
Directive closing conditional assembly block.

Syntax:
 
 .ENDIF	 

Example:
 
 .ENDIF ; end of conditional assembly block	 

=====.ERROR
Directive generation assembly error.

Syntax:
 
 .ERROR [txtexpr]	 

Example:
 
 .ERROR "Required text parameter missing in macro " + %0$	 

=====.REPEAT lub .REPT
Directive opening block of source text to be repeated given number of times.

Syntax:
 
[<label>[:]] .REPEAT expr	 

Example:
 
 .REPEAT 10  ; repeat 10 times	   
 .REPEAT %0  ; repeat as many times as number of macro params	   
 .REPEAT 4	   
    LSR	   
 .ENDR	 

=====.ENDR
Directive closing block of source text to repeat.

Syntax:

[<label>[:]] .ENDR

Example:

 .ENDR
